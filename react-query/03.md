# Query Key and queryCache

- A unique key for the query
- This is used as identifier for refetching, caching, deduping related queries

```jsx
const info = useQuery("orders", fetchPurchaseOrders);
```

## Is it string only

- can be string, array, complex objects or anything that is serializable
- Deep comapred with serialization (deterministic serialization)

**Array**:

```jsx
const info = useQuery(["order", orderId], fetchOrderDetails);
```

```jsx
const info = useQuery(["order", orderId, { orderType: "XYZ" }], fetchOrderDetails);
```

## Suggested pattern

Pass the dependant variables as items in the array query keys. They will get passed to the function.
Keeps the _query_ ideal.

Ex: we need to pull reason codes based on star rating. Now this may depend on user, order etc. If so include all of them in query key to avoid stale data.

```jsx
function orderDetails({ orderId, orderType }) {
  const queryInfo = useQuery(["order", orderId, { orderType }], fetchOrderDetails);
}

// Access status and page in your query function!
function fetchOrderDetails(key, orderId, { orderType }) {
  return new Promise();
  // ...
}
```

## Avoid doing

```jsx
function orderDetails({ orderId, orderType }) {
  const queryInfo = useQuery(["order", orderId], (...args) => {
    // you ignore args or don't know they exist
    // Here you are missing to add orderType to query key probably causing an issue
    // Try depending on the passed in props from query key
    fetchOrderDetails(orderId, orderType);
  });
}

// Access status and page in your query function!
function fetchOrderDetails(key, orderId, { orderType }) {
  return new Promise();
  // ...
}
```

## Parallel vs Serial Queries

- Parallel by default
- Searial(dependant) queries need to specify `enabled` flag

```jsx
// Get the user
const { data: user } = useQuery(["user", email], getUserByEmail);

// Then get the user's projects
const { isIdle, data: projects } = useQuery(["projects", user.id], getProjectsByUser, {
  // `user` would be `null` at first (falsy),
  // so the query will not execute until the user exists
  enabled: user,
});

// isIdle will be `true` until `enabled` is true and the query begins to fetch.
// It will then go to the `isLoading` stage and hopefully the `isSuccess` stage :)
```

## conditional queries

## isLoading vs isFetching

- `isLoading: true` for initial mounting period before query is resolved
- `isFetching: true && isLoading: false` for successive renders when data is fetched in background

---

### [Next](./04.md)
